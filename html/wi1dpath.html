<HTML><HEAD>   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">   <META NAME="Author" CONTENT="Jeremy Friesner">   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">   <TITLE>SockHop SHWi1dPathSorter Page</TITLE></HEAD><BODY><B><U>SHWi1dPathSorter class</U></B> (derivesfrom <A HREF="sorters.html">SHSorter</A>)<P>The SHWi1dPathSorter class defines the "normal" way of routing BMessagesunder SockHop.&nbsp; Whenever a new SockHop node is created, an SHWi1dPathSorterobject is automatically added to its available sorter list, and is madethe default sorter for all BMessages that the node handles.<P><B><U>Wi1dPath Routing Semantics</U></B><P>The SHWi1dPathSorter implements a BMessage routing mechanism based onfilesystem-like "path strings" through SockHop's virtual network tree.&nbsp;Because it is so simple and powerful, and because SockHop relies on itinternally, it is automatically created and made the default <A HREF="sorters.html">SHSorter</A>for any new node that SockHop creates.<P>The SHWi1dPathSorter bases all its message-forwarding decisions on onefield in the BMessages:&nbsp; SH_NAME_TO (aka "shTo", but it's better styleto use the symbol defined in &lt;sockhop/SockHopConstants.h>).&nbsp; Thisfield, if present, should contain an array of one or more "path strings"that dictate what paths through the tree the BMessage should take.<P>Each path string is interpreted by the SHWi1dPathSorter as a "virtualtree pathname" that specifies a set of nodes who are to receive this BMessage("receiving" the BMessage means that the BMessage is posted to all SHWorkersliving on that node, if they are interested in it).&nbsp; When there isone string is found in the SH_NAME_TO array, then the union of all thenodes specified by all strings in in the array will receive this BMessage.<P>If no SH_NAME_TO strings are present in the BMessage, on the other hand,then the BMessage is considered to be a "broadcast" message, and is sentto every node in the tree (so remember to add an appropriate SH_NAME_TOfield to all your BMessages if you don't want them to go everywhere!!!).<P>The format of each string should be familiar to anyone who has usedany shell under BeOS or UNIX--it is a pathname with the same conventionsas any filesystem pathname.&nbsp; If you imagine SockHop's virtual networktree to be a tree of directories in a filesystem, and the node that theBMessage is posted to to be the "current directory", then you have theright idea.<P><B><U>Some Examples of SHWi1dPathSorter Routing</U></B><BR><A NAME="Examples"></A><BR>Let's say your SockHop program has created the following virtual networktree:<BR>&nbsp;<BR><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_____"/"_____</TT></NOBR><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Red"&nbsp; "Green"&nbsp; "Blue"</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; \</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp; \</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; \</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Pink" "Mauve" "Puce" "Cyan" "Navy"</NOBR></TT><P>As you can see, the root node of the tree is name "/".&nbsp; The rootnode is the one returned by the call to SHCreateRootNode(), and it is <B>always</B>named "/".&nbsp; No exceptions!<P>The root node has spawned three children, named "Red", "Green", and"Blue".&nbsp; "Red", in turn, has two children named "Pink" and "Mauve";"Green" has one child name "Puce"; and "Blue" has two children named "Cyan"and "Navy".&nbsp; Each of these nodes has a unique absolute pathname, generatedby concatenating node names while traversing the path from the root tothe node:<BR>&nbsp;<CENTER><TABLE BORDER ><TR><TD><B>Node Name</B></TD><TD><B>Absolute Node Path</B></TD></TR><TR><TD>"/"</TD><TD>"/"</TD></TR><TR><TD>"Red"</TD><TD>"/Red"</TD></TR><TR><TD>"Green"</TD><TD>"/Green"</TD></TR><TR><TD>"Blue"</TD><TD>"/Blue"</TD></TR><TR><TD>"Pink"</TD><TD>"/Red/Pink"</TD></TR><TR><TD>"Mauve"</TD><TD>"/Red/Mauve"</TD></TR><TR><TD>"Puce"</TD><TD>"/Green/Puce"</TD></TR><TR><TD>"Cyan"&nbsp;</TD><TD>"/Blue/Cyan"</TD></TR><TR><TD>"Navy"&nbsp;</TD><TD>"/Blue/Navy"&nbsp;</TD></TR></TABLE></CENTER><TT>&nbsp;</TT><BR>Now then, to send a BMessage to a specific node on the tree is easyenough; just specify the node's path name:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Red/Mauve");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rootNode->PostMessage(&amp;myMessage);</NOBR></TT><TT></TT><P>And sending a BMessage to a list of nodes is just as easy, you don'teven have to call PostMessage() multiple times:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Red/Mauve");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Blue");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Blue/Navy");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rootNode->PostMessage(&amp;myMessage);</NOBR></TT><P>Even better, you can use regular expressions (a.k.a. wildcarding) toimplicitly specify complex sets of nodes.&nbsp; For example, this codewill send a BMessage to every grandchild in the tree (that is, to "Pink","Mauve", "Puce", "Cyan", and "Navy"):<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/*/*");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rootNode->PostMessage(&amp;myMessage);</NOBR></TT><P>And feel free to mix different methods together;&nbsp; since the BMessageis delivered to the <I>union </I>of the nodes specified by each path string,you don't have to worry that specifying a node more than once will causeit to receive more than one copy of the BMessage:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/*");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// message goes to all top-level children</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Blue/*");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and all of Blue's children</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/Blue/Navy");&nbsp;&nbsp;&nbsp; // this <B>won't</B> cause Navy to gettwo copies!</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rootNode->PostMessage(&amp;myMessage);</NOBR></TT><P>Another feature that the SHWi1dPathSorter shares with the BeOS filesystemsis the abilitity to use relative pathnames.&nbsp; If you do not specifythe leading slash in your path string, then the message will be deliveredto nodes relative to the "current node"--that is, the node to which theBMessage was directly posted.<P>As an example, consider this code, that is running within an SHComponent(that is, either an SHSorter or an SHWorker) on one of the nodes in thetree:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"*a*");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessageToNode(&amp;myMessage);</NOBR></TT><P>If the SHComponent posting this message is running on "Blue", then theBMessage will be delivered to both "Cyan" and "Navy", since they are bothchildren of "Blue" and have the letter "a" in their node name.&nbsp; Butif this code were executed from within an SHComponent running on "Red",then only "Mauve" would receive the BMessage, as "Pink" has no "a" in it.<P>BMessages posted by the main user program (that is, the code that calledSHCreateRootNode() to create the SockHop network) are always posted startingat the root of the tree, and thus generally propagate down the tree.&nbsp;Code running on nodes within the tree, however, may want to send BMessagesback up the tree.&nbsp; Once again, the syntax for doing this comes straightfrom filesystem parlance:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"..");</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessageToNode(&amp;myMessage);</NOBR></TT><P>This, of course, sends the BMessage to the parent node of the node thiscode's SHComponent is running on.&nbsp; Other permutations, such as "../.."(go up two levels in the tree), or "../Blue" (go up one to our node's parent,then down to its child named "Blue"), etc, will also work as expected.<P>If a BMessage posted from an SHComponent in the virtual network treeuses an absolute pathname (i.e., one with a leading slash), then the BMessagewill be sent all the way up to the root node of the tree before propagatingback down to their destination.&nbsp; This can be inefficient (lots ofmessage hops!), so you may prefer to have your SHComponents use relativepathnames wherever possible.<P>But what if an SHComponent wants to send a BMessage back to the mainuser program?&nbsp; The main program does not have a node on the tree toidentify it; so what pathname should be given?&nbsp; The short answer is:&nbsp;to send a BMessage back to the main program, use the magical pathname "/.."<P>Well, actually that pathname isn't really magical.&nbsp; It works becauseyour main user program's target BLooper (the one you specified in yourcall to SHCreateRootNode()) is considered to be living "above" the rootnode of the SockHop tree.&nbsp; Thus, the pathname "/.." does two things--theslash takes the BMessage to the root node (following the rule for absolutepathnames described above) and from there, the ".." raises it one morelevel, out the top of the tree and back your target BLooper.&nbsp; Youcould also send the BMessage back to the main user program by specifyinga pathname like "../../../../..", where the number of ".."'s in the pathnameis greater than or equal to your posting component's node's depth in thetree.<P>Lastly, the node name "." can be used to refer to the current node,just like the "current directory" in a filesystem.<P><A NAME="ToWorkers"></A><B><U>Specifying which SHWorkers the BMessageshould go to</U></B><P>Once your BMessage has arrived at its destination node(s), you may wantto further specify which of the <A HREF="workers.html">SHWorkers</A> onthose nodes should get the BMessage.&nbsp; By default, every <A HREF="workers.html#IsInterestedIn">interestedSHWorker</A> on a destination node is given a copy of the BMessage.&nbsp;To specify just a subset of <A HREF="workers.html">SHWorkers</A>, however,you can specify them by name in the SH_NAME_TOWORKERS field of your BMessage.&nbsp;This field takes one or more strings, each of which may be the name ofan <A HREF="workers.html">SHWorker</A> (as returned by the SHWorker's GetName()method), or a regular expression to specify multiple <A HREF="workers.html">SHWorkers</A>.&nbsp;The BMessage will be routed to the union of the workers specified in theSH_NAME_TOWORKERS field.&nbsp; For example:<P><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BMessagemyMessage('test');</NOBR></TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TO,"/ANode/In/The/Tree");&nbsp; // specify destination node</NOBR></TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TOWORKERS,"Fred");&nbsp; // give Fred a copy</TT><BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myMessage.AddString(SH_NAME_TOWORKERS,"G*");&nbsp; // also give George, Gary, and Gracy a copy</TT><BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PostMessageToNode(&amp;myMessage);</NOBR></TT><BR>&nbsp;<BR>&nbsp;</BODY></HTML>