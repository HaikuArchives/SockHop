<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>SockHop SH_COMMAND page</TITLE>
</HEAD>
<BODY>
<B><U>The SockHop BMessage protocol</U></B>

<P>The SockHop node tree communicates with user code solely by means of
BMessages.&nbsp; When you create the root SockHop node, you pass in a BMessenger
object to the <A HREF="functions.html">SHCreateRootNode</A>() function.&nbsp;
Whenever SockHop wants to tell you something, it will send a BMessage via
this BMessenger.&nbsp; Your receiving code (which can be a BLooper object
or anything else that a BMessenger can send to) can then handle the BMessage
as it sees fit.&nbsp; The root node object returned by <A HREF="functions.html">SHCreateRootNode</A>()
is a type of BLooper, so to send a BMessage to SockHop, all you need to
do is call PostMessage() on the root node object.

<P>All the BMessage 'what' values that SockHop recognizes are enumerated
in the header file &lt;sockhop/SockHopConstants.h>.&nbsp; The command codes
all have the form SH_COMMAND_(something).&nbsp; If you send SockHop a BMessage
with any other value besides these, it will assume that the BMessage is
meant for add-on code (<A HREF="sorters.html">SHSorters</A> or <A HREF="workers.html">SHWorkers</A>)
and will route the BMessage normally and give it to the <A HREF="workers.html">SHWorkers</A>
on any receiving nodes.

<P>In addition to the 'what' code, SockHop also looks in each BMessage
you send it for <A HREF="sh_names.html">certain fields</A>.&nbsp; These
fields are also enumerated in &lt;sockhop/SockHopConstants.h>, and are
listed with names that have the form SH_NAME_(something).&nbsp; The field
name values all start with the lower case letters "sh", followed by a capital
letter, and possibly some additional letters.&nbsp; To avoid possible conflicts
and confusion, it is strongly suggested that your code not use similarly
named fields in BMessages for its own purposes.&nbsp; Furthermore, it is
suggested that you always use the SH_NAME_* identifiers in your code instead
of the actual strings they represent.&nbsp; This reduces the chances of
typos going uncaught in your code, and make it easier to recompile your
code for new versions of SockHop should the string values ever change.
<BR>&nbsp;
<BR><B><U>SH_COMMAND 'what' values that SockHop understands, and what they
mean.</U></B>

<P>
<HR WIDTH="100%">
<UL>
<LI>
SH_COMMAND_BASE</LI>
</UL>
This actually isn't a SockHop command, it's just here to mark the beginning
of the command value range.&nbsp; SockHop will treat BMessages with this
'what' value the same as any user message type.

<P>
<HR WIDTH="100%">
<UL>
<LI>
<A NAME="addcomponents"></A>SH_COMMAND_ADDCOMPONENTS</LI>


<P>You can send a BMessage of this command type to any node in the SockHop
tree, to tell it to add various things to itself.&nbsp; Specifically, you
can tell it to create and add <A HREF="shfilespecs.html">files</A>, symlinks,
new <A HREF="shnodespecs.html">child nodes</A>, new <A HREF="workers.html">SHWorkers</A>,
and/or new <A HREF="sorters.html">SHSorters</A>.&nbsp; For <A HREF="distributableobject.html">objects</A>
that require an add-on file, SockHop will automatically download and cache
the add-on file as necessary, to any node where the objects in that add-on
file are to be instantiated.&nbsp; When a SockHop node receives a BMessage
of this type, it will look for the following fields in the BMessage (any
or all of these fields may be present):</UL>
&nbsp;
<TABLE BORDER WIDTH="98%" >
<CAPTION><B>Fields that can be added to an SH_COMMAND_ADDCOMPONENTS BMessage</B></CAPTION>

<TR>
<TD>SH_NAME_SORTERS</TD>

<TD>This field should be an array of one or more BMessages that were generated
by calling the Archive() method on <A HREF="sorters.html">SHSorter</A>-subclass
objects.&nbsp; The receiving node(s) will download and unarchive each <A HREF="sorters.html">SHSorter</A>
in this array, and add them to their list of active <A HREF="sorters.html">SHSorters</A>.</TD>
</TR>

<TR>
<TD>SH_NAME_WORKERS</TD>

<TD>This field should be an array of one or more BMessages that were generated
by calling the Archive() method on <A HREF="workers.html">SHWorker</A>-subclass
objects.&nbsp; The receiving node(s) will download and unarchive each <A HREF="workers.html">SHWorker</A>
in this array, and add them to their list of active <A HREF="workers.html">SHWorkers</A>.</TD>
</TR>

<TR>
<TD>SH_NAME_CHILDREN</TD>

<TD>This field should be an array of one or more flattened <A HREF="shnodespecs.html">SHNodeSpecs</A>,
each added to the BMessage via AddFlat().&nbsp; Each <A HREF="shnodespecs.html">SHNodeSpec</A>
in the array represents a description of a new node that the receiver of
this BMessage should create and connect to.&nbsp;&nbsp; The new nodes are
added to the tree as children of the node that received this BMessage.</TD>
</TR>

<TR>
<TD>SH_NAME_FILES</TD>

<TD>This field should be an array of one or more flattened <A HREF="shfilespecs.html">SHFileSpecs</A>,
each added to the BMessage via AddFlat().&nbsp; Each <A HREF="shfilespecs.html">SHFileSpec</A>
represents one set of files that should be cached on the receiving node(s).&nbsp;
The node will read each <A HREF="shfilespecs.html">SHFileSpec</A> and make
sure that it has an up-to-date version of each file that the <A HREF="shfilespecs.html">SHFileSpec</A>
specifies.&nbsp; If it does not, it will request a copies of the missing/out-of-date
files from the nodes above it in the tree.</TD>
</TR>

<TR>
<TD>SH_NAME_SYMLINKS</TD>

<TD>Not filesystem symlinks!&nbsp; This field should be an array of one
or more strings.&nbsp; It works somewhat similarly to the SH_NAME_CHILDREN
field (described above), except that instead of instantiating new child
nodes, it creates "fake" children that are really pointers to currently
existing nodes.&nbsp; Each string in this field should contain a node path
designating one or more target nodes in the tree.&nbsp; Each node path
may contain wildcards, in which case more than one symlink may be created.&nbsp;
Each symlink that is created will appear as a child underneath the connecting
node, and will have the same name as the node that was connected to.&nbsp;

<P><B>NOTE</B>:&nbsp; Be careful when creating symlinks that cause cycles
in the node graph!&nbsp; It opens the door to potential infinite loops
of BMessage transmission (e.g., using the default sorter and not specifying
an SH_NAME_TO field in a BMessage would cause a broadcast transmission
that would cycle through the graph indefinitely!)&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<UL><A HREF="sh_command_addcomponents.html">Click here for examples of
how to use SH_COMMAND_ADDCOMPONENTS.</A></UL>

<HR WIDTH="100%">
<UL>
<LI>
<A NAME="removecomponents"></A>SH_COMMAND_REMOVECOMPONENTS</LI>


<P>You can send a BMessage of this command type to any node in the SockHop
tree, to tell it to remove various things from itself.&nbsp; In particular,
you can tell it to delete files, <A HREF="shnodespecs.html">child nodes</A>,
<A HREF="shnodespecs.html">symlinks</A>, <A HREF="workers.html">SHWorkers</A>,
and/or <A HREF="sorters.html">SHSorters</A>.&nbsp; When a SockHop node
receives a BMessage of this type, it will look for the following fields
in the BMessage (any or all of these fields may be present):</UL>
&nbsp;
<TABLE BORDER WIDTH="98%" >
<CAPTION><B>Fields that can be added to an SH_COMMAND_REMOVECOMPONENTS
BMessage</B></CAPTION>

<TR>
<TD>SH_NAME_SORTERS</TD>

<TD>This field should be an array of one or more strings.&nbsp; Each string
in the array should be a regular expression that will be compared against
the names of the <A HREF="sorters.html">SHSorters</A> in the receiving
node's worker list.&nbsp; The receiving node will remove and delete any
<A HREF="sorters.html">SHSorters</A> whose names match one or more of the
regular expressions in this field.</TD>
</TR>

<TR>
<TD>SH_NAME_WORKERS</TD>

<TD>This field should be an array of one or more strings.&nbsp; Each string
in the array should be a regular expression that will be compared against
the names of the <A HREF="workers.html">SHWorkers</A> in the receiving
node's worker list.&nbsp; The receiving node will remove and delete any
<A HREF="workers.html">SHWorkers</A> whose names match one or more of the
regular expressions in this field.</TD>
</TR>

<TR>
<TD>SH_NAME_CHILDREN</TD>

<TD>This field should be an array of one or more strings.&nbsp; Each string
in the array should be a regular expression that will be compared against
the names of the child nodes of the receiving node.&nbsp; The receiving
node will remove any children whose names match one or more of the regular
expressions in this field.&nbsp; If the removed children are "real" children,
this will cause them to be destroyed; if the removed children are actually
symlinks, this will just remove the symlink to the child without affecting
the child itself.</TD>
</TR>

<TR>
<TD>SH_NAME_FILES</TD>

<TD>This field should be an array of one or more flattened <A HREF="shfilespecs.html">SHFileSpecs</A>.&nbsp;
Each receiving node will iterate over each SHFileSpec in the array, and
delete from the local filesystem every file specified by each <A HREF="shfilespecs.html">SHFileSpec</A>.</TD>
</TR>

<TR>
<TD>SH_NAME_SYMLINKS</TD>

<TD>This works the same as the SH_NAME_CHILDREN field (see above), except
that it will only affect symlink children--connections to real children
are not broken.&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<UL><A HREF="sh_command_removecomponents.html">Click here for examples
of how to use SH_COMMAND_REMOVECOMPONENTS.</A>
<BR>&nbsp;</UL>

<HR WIDTH="100%">
<UL>
<LI>
<A NAME="setParameters"></A>SH_COMMAND_SETPARAMETERS</LI>


<P>This command can be used to set various miscellaneous parameters on
the receiving node.&nbsp; Parameter names and values should be added directly
to the BMessage, with the parameter's name being the field name, and the
value being the data associated with that field.
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR>
<TD>SH_PARAMNAME_DEBUG</TD>

<TD>An int32 field.&nbsp; Sets the debug output level of the targetted
nodes.&nbsp; Currently, there are only two levels:&nbsp; 0 (no debug output),
and non-zero (debug output)</TD>
</TR>

<TR>
<TD>SH_PARAMNAME_DEFAULTSORTER</TD>

<TD>A string field.&nbsp; Sets the default sorter for the receiving node
to the first one of the node's available sorter list whose GetName() method
returns the string specified in this field.</TD>
</TR>

<TR>
<TD>SH_PARAMNAME_THREADPRIORITY</TD>

<TD>An int32 field.&nbsp; Sets the thread priority that will be given to
newly spawned SockHop threads.</TD>
</TR>

<TR>
<TD>SH_PARAMNAME_TRANSMISSIONENCODING</TD>

<TD>An int32 field.&nbsp; Sets the BMessage encoding that will be used
by newly spawned TCP connections.&nbsp; The value given here should be
one of the SH_ENCODING_* tokens specified in SockHopConstants.h.</TD>
</TR>
</TABLE>
&nbsp;

<P><A HREF="sh_command_setparameters.html">Click here for an example of
how to use SH_COMMAND_SETPARAMETERS.</A></UL>

<HR WIDTH="100%">
<UL>
<LI>
SH_COMMAND_GETPARAMETERS</LI>


<P>This command can be used to query a node for the state various parameters.&nbsp;
The names of the parameters you are interested in should be added to the
BMessage with AddString(parameterName, ""), and fields with same names
and the appropriate values will be added to the SH_NAME_ONSUCCESS message
that is sent back.&nbsp; Note that this command is pretty useless unless
you do specify an SH_NAME_ONSUCCESS field with it!

<P>For a list of valid parameter names, see the SH_COMMAND_SETPARAMETERS
documentation.

<P><A HREF="sh_command_getparameters.html">Click here for examples of how
to use SH_COMMAND_GETPARAMETERS.</A></UL>

<HR WIDTH="100%">
<UL>
<LI>
SH_COMMAND_QUIT</LI>


<P>This command tells the receiving node to terminate.&nbsp; When a node
terminates, all descendants of that node are implicitely terminated as
well.&nbsp; (This message type has the same effect as calling Lock() and
Quit() on the receiving node)
<UL>&nbsp;</UL>
<A HREF="sh_command_quit_example.html">Click here for an example of how
to use SH_COMMAND_QUIT.</A></UL>

<HR WIDTH="100%">
<UL>
<LI>
SH_COMMAND_LARGEST</LI>


<P>This isn't a real command either, but rather just serves to mark the
end of the current SH_COMMAND_* range.&nbsp; If a BMessage with this type
is sent, it will be interpreted as a regular user message.</UL>
&nbsp;
</BODY>
</HTML>
