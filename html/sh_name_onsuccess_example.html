<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>Example of SH_NAME_ONSUCCESS</TITLE>
</HEAD>
<BODY>
<B>Basic Examples of how to use SH_NAME_ONSUCCESS</B>

<P>
<HR WIDTH="100%">

<P>Example 1:&nbsp; Detecting when your network connections have been successfully
set up.

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // For this example, we will add one child,
named "Joe", to the root node.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage msg(SH_COMMAND_ADDCOMPONENTS);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddString(SH_NAME_TO, "/");</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddFlat(SH_NAME_CHILDREN, &amp;SHNodeSpec("Joe",
"beos.sockhop.com"));</TT></NOBR>
<BR><NOBR><TT>&nbsp;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // Since we want to know when it succeeds,
we add a BMessage to it that will be sent back to us...</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage onSuccessMsg('sxss');&nbsp;&nbsp;&nbsp;&nbsp;
// choose any 'what' value here that you will recognize later</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // Address the success message to ourself.&nbsp;
Remember that it will be posted</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // from the parent of the newly created
node.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; onSuccessMsg.AddString(SH_NAME_TO, "/..");</TT></NOBR>
<BR><NOBR><TT>&nbsp;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // Finally, add the on-success BMessage
to the original BMessage before sending it.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddMessage(SH_NAME_ONSUCCESS, &amp;onSuccessMsg);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; root->PostMessage(&amp;msg);</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>[... meanwhile, in your target BLooper's MessageReceived()
method...]</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; void MyLooper :: MessageReceived(BMessage
* msg)</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; {</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg->what
== 'sxss')</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf("Got a success message back!&nbsp; Our connection must have succeeded!\n");</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// We can find out exactly who it was who succeeded this way:</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SHNodeSpec whoWasIt;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (msg->FindFlat(SH_NAME_REGARDING, &amp;whoWasIt) == B_NO_ERROR)</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
printf("The child who was created successfully is:\n");</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
whoWasIt.PrintToStream();</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; }</TT></NOBR>

<P>
<HR WIDTH="100%">

<P>Example 2:&nbsp; Detecting when your add-on worker has started running
on a remote node:

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // Okay, let's start a TestWorker object
running on the node "/Joe"</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // ("/Joe" is assumed to already be set
up and running in your node tree)</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage msg(SH_COMMAND_ADDCOMPONENTS);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddString(SH_NAME_TO, "/Joe");</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // Create a worker, capture his soul into
a BMessage, and add him to our request BMessage.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; TestWorker worker;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage archive;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; worker.Archive(&amp;archive);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddMessage(SH_NAME_WORKERS, &amp;archive);</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // Now create a self-addressed, stamped
BMessage that will be posted by "/Joe"</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // as soon as the TestWorker is running
there.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage onSuccess('SuCC');</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; onSuccess.AddString(SH_NAME_TO, "/..");</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; msg.AddMessage(SH_NAME_ONSUCCESS, &amp;onSuccess);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; root->PostMessage(&amp;msg);</TT></NOBR>

<P>
<HR WIDTH="100%">

<P><B>Fancy Examples of SH_NAME_ONSUCCESS</B>

<P>
<HR WIDTH="100%">

<P>Example 3:&nbsp; "Daisy-chaining" a BMessage.&nbsp; Imagine you have
three nodes in your tree, "/Peter", "/Paul", and "/Mary."&nbsp; Imagine
that you (for some reason) want to send a BMessage that travels to each
of these nodes, <I>in succession</I>.&nbsp; That is, it should go to Peter,
<I>then</I> Paul, <I>then</I> Mary.&nbsp; (Contrast this example to routing
the BMessage to all three nodes in parallel, where it would be a simple
matter of giving the BMessage an SH_NAME_TO field like "/*")&nbsp; Because
a user-level BMessage succeeds exactly once on each node it is received
by, you can use SH_NAME_ONSUCCESS to accomplish this behavior:

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // First, here is the BMessage we want
each node to receive.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage toPeter('Helo');&nbsp;&nbsp;&nbsp;
// Some user BMessage, doesn't matter what.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Will be received by the SHWorkers on "/Peter".</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // (toPeter) will go to "/Peter".</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; toPeter.AddString(SH_NAME_TO, "/Peter");</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // When it arrives at Peter, it will post
its success BMessage.&nbsp; That BMessage will go to Paul.</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage toPaul('Helo');</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; toPaul.AddString(SH_NAME_TO, "/Paul");</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // And when (toPaul) arrives at Paul, it
should post (toMary).</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; BMessage toMary('Helo');</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; toMary.AddString(SH_NAME_TO, "/Mary");</TT></NOBR>
<BR><NOBR><TT>&nbsp;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // Now we compose the BMessages together,
innermost first (order matters!)</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; toPaul.AddMessage(SH_NAME_ONSUCCESS, &amp;toMary);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; toPeter.AddMessage(SH_NAME_ONSUCCESS,
&amp;toPaul);</TT></NOBR>
<BR><NOBR><TT>&nbsp;</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // And off we go!</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; root->PostMessage(&amp;toPeter);</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp;&nbsp; // For extra fun, you could add an SH_NAME_ONSUCCESS
field to Mary, containing a</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // BMessage addressed to "/..".&nbsp;
That way you would be notified when the BMessage</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp;&nbsp; // had finished making the rounds.</TT></NOBR>
<BR>&nbsp;
<BR>&nbsp;
</BODY>
</HTML>
