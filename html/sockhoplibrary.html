<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>Programming with libsockhop.so</TITLE>
</HEAD>
<BODY>
<B><U>Programming with libsockhop.so (the
SockHop shared library)</U></B>

<P><A HREF="#Overview">Overview</A>
<BR><A HREF="#Network Architecture">Virtual network architecture</A>
<BR><A HREF="#Program Flow">Format of a typical SockHop program</A>
<BR><A HREF="#Example program">Example program source</A>
<BR><A HREF="#Compiling">Compiling SockHop programs</A>
<BR><A HREF="#workers">Writing your own SHWorker subclasses</A>
<BR><A HREF="#sorters">Writing your own SHSorter subclasses</A>
<BR>&nbsp;

<P><A NAME="Overview"></A>
<BR><B><U>Overview:&nbsp; The environment under SockHop</U></B>

<P>SockHop is a software kit designed to allow BeOS programs to run easily
on many (many!) machines at once.&nbsp; It is designed mainly for controlled
environments where the programmer has access to and control over one or
more BeOS machines, and knows in advance which machines will be used to
run the parallel program.&nbsp; Using SockHop, the programmer can write
a program on a single BeOS machine, but test and run it on every machine
in the lab, without ever needing to leave his or her chair.&nbsp; SockHop
handles all the network communication, message routing, code propagation,
and so on, leaving the programmer free to concentrate on the actual application.
<BR>&nbsp;

<P><A NAME="Network Architecture"></A>
<BR><B><U>SockHop's Virtual Network Architecture</U></B>

<P>In a SockHop program, the "SockHop Virtual Machine" takes the form of
a tree of nodes.&nbsp; For many applications, the tree need not be more
than one or two levels deep, but theoretically the tree could grow to any
size or depth.

<P>Here are some important qualities of the tree:
<UL>
<LI>
Each node in the tree is given a name, and is addressable via a "path",
much like a node in a hierarchical filesystem.&nbsp; The root node's name
is always "/", but the names of all the other nodes are assigned by the
programmer.</LI>

<LI>
The root node of the tree always lives as a thread in the same team as
the BeOS program that created it.&nbsp; Every other node in the tree can
(optionally) live in its own team, or even on its own computer.&nbsp; Or,
it can run as a thread inside the same team as its parent node.&nbsp; Whatever
configuration is chosen, it's totally transparent to user code.</LI>

<LI>
Each node may contain one or more <A HREF="workers.html">SHWorkers</A>.&nbsp;
<A HREF="workers.html">SHWorkers</A> are really just glorified BLoopers,
and operate in a similar way.&nbsp; The main difference is that <A HREF="workers.html">SHWorkers</A>
are subclasses of <A HREF="distributableobject.html">SHDistributableObject</A>,
and thus can be Archive()'d and automatically migrated (executable code
and all) to run on other computers in the tree.</LI>

<LI>
Each node also contains one or more <A HREF="sorters.html">SHSorters</A>,
which control how incoming BMessages are routed.&nbsp; When a new node
is created, it is automatically given an <A HREF="wi1dpath.html">SHWi1dPathSorter</A>,
which allows BMessages to be routed using regular expressions and pathnames.&nbsp;
For most applications, this will be the only <A HREF="sorters.html">SHSorter</A>
you need.&nbsp;&nbsp; If you want to get fancy, however, you can define
your own <A HREF="sorters.html">SHSorter</A> subclasses, and thus your
own BMessage-routing protocol.&nbsp; You can specify, for each BMessage
you send, which <A HREF="sorters.html">SHSorter</A> should be used to route
it.</LI>
</UL>
<A NAME="Program Flow"></A>
<BR>&nbsp;

<P><B><U>Format of a typical SockHop program.</U></B>

<P>A typical SockHop program will do the following things:
<OL>
<LI>
Create or designate a BLooper that SockHop will send its reply BMessages
to.</LI>

<LI>
Create the root node of a virtual network by calling <A HREF="functions.html">SHCreateRootNode</A>().</LI>

<LI>
Post BMessages to the root node telling it to <A HREF="sh_command_addcomponents.html">create
some child nodes</A> (and possibly after that post messages to some of
the child nodes telling them to create grandchild nodes, and so on)</LI>

<LI>
Instantiate some objects of one or more <A HREF="workers.html">SHWorkers</A>
subclasses, Archive() them, and send them to various nodes.</LI>

<LI>
Post BMessages to control the behavior of the <A HREF="workers.html">SHWorkers</A>,
and receive BMessages from the <A HREF="workers.html">SHWorkers</A> that
indicate the results.</LI>

<LI>
When all is done, call Lock() and Quit() on the root node (since the root
node is a BLooper), and exit. Destroying the root node will cause the rest
of the tree to disappear as well.</LI>
</OL>
&nbsp;

<P><A NAME="Example program"></A>
<BR><B><U>A simple example</U></B>

<P>Here is an example of a simple, do-almost-nothing SockHop program.&nbsp;
It assumes the following conditions are true:
<OL>
<LI>
There exist computers named beos1.sockhop.com, beos2.sockhop.com, and beos3.sockhop.com,
on the network, and that they are all running BeOS, and that they all have
a <A HREF="sockhopserver.html">SockHop server</A> running on port 2958
(the default SockHop port)</LI>

<LI>
An add-on file containing an SHWorker subclass named SHTestWorker has been
placed in the correct location(s) relative to this program's current directory
(the actual place it needs to be is up to the add-on code, but is often
something like "./add-ons/x86/SHTestWorker" for the Intel flavor, and "./add-ons/ppc/SHTestWorker"
for the PowerPC flavor)</LI>

<LI>
This program needs to link against the SHTestWorker add-on, in order to
construct an SHTestWorker object to Archive() and send.&nbsp; Thus, the
SHTestWorker add-on must be in a directory specified by the LIBRARY_PATH
variable (otherwise, this program won't execute at all!)</LI>
</OL>
<TT>/*----------- begin sample code ----------- */</TT>

<P><TT><NOBR>#include &lt;sockhop/SockHop.h></NOBR></TT>
<BR><TT><NOBR>#include "SHTestWorker.h"</NOBR></TT>

<P><TT><NOBR>// We need a BLooper to receive the BMessages that SockHop</NOBR></TT>
<BR><TT><NOBR>// sends back to us.&nbsp; This one will just print out any</NOBR></TT>
<BR><TT><NOBR>// BMessage it receives.</NOBR></TT>
<BR><TT><NOBR>class DebugLooper : public BLooper</NOBR></TT>
<BR><TT><NOBR>{</NOBR></TT>
<BR><TT><NOBR>private:</NOBR></TT>
<BR><TT><NOBR>&nbsp; virtual void MessageReceived(BMessage * msg)</NOBR></TT>
<BR><TT><NOBR>&nbsp; {</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp; printf("DebugLooper:&nbsp; Received
this message from SockHop:\n");</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp; msg->PrintToStream();</NOBR></TT>
<BR><TT><NOBR>&nbsp; }</NOBR></TT>
<BR><TT><NOBR>};</NOBR></TT>

<P><TT><NOBR>int main(int argc, char ** argv)</NOBR></TT>
<BR><TT><NOBR>{</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // Create a target BLooper to receive reply
BMessages</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; DebugLooper * debugLooper = new DebugLooper;</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; debugLooper->Run();</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Create the root node ("/") of the SockHop
tree</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; BLooper * root = SHCreateRootNode(BMessenger(debugLooper));</NOBR></TT>
<BR><TT>&nbsp;&nbsp; if (root == NULL)</TT>
<BR><TT>&nbsp;&nbsp; {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error, couldn't create root
node!\n");</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(5);</TT>
<BR><TT>&nbsp;&nbsp; }</TT>
<BR><TT><NOBR>&nbsp;&nbsp; root->Run();</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Tell the root node to add our three computers
as children.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; BMessage createKids(SH_COMMAND_ADDCOMPONENTS);</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; createKids.AddFlat(SH_NAME_CHILDREN, &amp;SHNodeSpec("node-A",
"beos1.sockhop.com"));</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; createKids.AddFlat(SH_NAME_CHILDREN, &amp;SHNodeSpec("node-B",
"beos2.sockhop.com"));</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; createKids.AddFlat(SH_NAME_CHILDREN, &amp;SHNodeSpec("node-C",
"beos3.sockhop.com"));</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; createKids.AddString(SH_NAME_TO, "/");</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; root->PostMessage(&amp;createKids);</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Create an SHTestWorker, and then capture its
essence into a BMessage.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // SHWorkers (and hence SHTestWorkers), unlike
real BLooper subclasses, can be</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // safely created on the stack.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; SHTestWorker testWorker("I'm a test worker!");</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; BMessage testWorkerMsg;</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; testWorker.Archive(&amp;testWorkerMsg);</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Now send a copy of the SHTestWorker to all
three child nodes.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // Note how wildcarding is used to specify all
three children's</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // node paths ("/node-A", "/node-B", and "/node-C")
at once.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; BMessage sendWorker(SH_COMMAND_ADDCOMPONENTS);</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; sendWorker.AddMessage(SH_NAME_COMPONENTS, &amp;sendWorker);</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; sendWorker.AddString(SH_NAME_TO, "/node-*");</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; root->PostMessage(&amp;sendWorker);</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Now we will send a BMessage to the SHTestWorkers,
just</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // for fun.&nbsp; How they interpret it is up
to them.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; BMessage msg('helo');</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; msg.AddString(SH_NAME_TO, "/node-*");</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; root->PostMessage(&amp;sendWorker);</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // Lastly, we shut down our root node and debugLooper.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // Note that shutting down the root node will
cause</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // the three remote nodes to automatically shut
down as well.</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; if (root->Lock()) root->Quit();</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; if (debugLooper->Lock()) debugLooper->Quit();</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; return 0;</NOBR></TT>
<BR><TT><NOBR>}</NOBR></TT>

<P><TT><NOBR>/* --------- end sample code ------------ */</NOBR></TT>

<P><TT><NOBR>&nbsp;</NOBR></TT>
<BR><A NAME="Compiling"></A>
<BR><B><U>Tips for compiling SockHop programs</U></B>

<P>When compiling SockHop programs, here are some useful facts to keep
in mind:
<UL>
<LI>
SockHop executables should link against libsockhop.so, and also against
any SockHop add-ons that define <A HREF="workers.html">SHWorker</A> or
<A HREF="sorters.html">SHSorter</A> subclasses that they wish to instantiate
and propagate across the virtual network.&nbsp; (Note:&nbsp; this isn't
quite true--you can use <A HREF="functions.html">SHCreateDistributableObject</A>()
to dynamically link with add-ons at run time, instead)&nbsp; It is recommended
that add-on files that are to be propagated to other computers be stored
in a subdirectory of the current directory of the initiating SockHop program,
using a relative path such as "adds-ons/x86/AddOnName" (referencing add-on
files with absolute pathnames will work, may cause conflicts with other
programs).&nbsp; The exact required location of the add-on file at run-time
is up to the writer of the add-on, though.&nbsp; The caching mechanism
assumes that all necessary files can be found on the root node's filesystem.</LI>

<LI>
The only file you need to #include in your programs is &lt;sockhop/SockHop.h>.&nbsp;
This file pulls in everything that is available in the SockHop API.</LI>

<LI>
The "meaty" parts of your code should be written as SHWorker subclass implementations,
because <A HREF="workers.html">SHWorkers</A> can be propagated to other
machines easily.&nbsp; Your main program will probably just control startup
and shutdown.</LI>

<LI>
If you have more than one <A HREF="workers.html">SHWorker</A> or <A HREF="sorters.html">SHSorter</A>
subclass defined for your project, it is legal to include all of them in
the same add-on file or shared library for convenience.&nbsp; Be sure to
put "#pragma export on ... #pragma export reset" (for PPC) or "_EXPORT"
(for Intel) tags around the class declarations in your add-on's header
files!</LI>

<LI>
While SockHop's application signature is available in &lt;sockhop/SockHop.h>,
it is not necessary to set this attribute in your add-on files for SockHop
to work properly.&nbsp; This is because SockHop uses its own mechanism
(the results of the SHDistributableObject::GetAddOnSpec() call) to locate
add-on files by pathname, instead of relying on instantiate_object() to
find them.</LI>
</UL>
<A NAME="workers"></A>
<BR>&nbsp;

<P><B><U>Writing your own SHWorker subclasses</U></B>

<P>Writing <A HREF="workers.html">SHWorker</A> subclasses is something
every SockHop programmer has to do in order to create code that can be
automatically propagated to multiple machines.&nbsp; Fortunately, <A HREF="workers.html">SHWorkers</A>
are very similar in concept to BLoopers, so you probably already mostly
know how they work.&nbsp; The rest of what you need to do to implement
an <A HREF="workers.html">SHWorker</A> can be found by reading the <A HREF="workers.html">SHWorker
class documentation</A>, and by remembering the tips below:
<UL>
<LI>
To be propagatable, your <A HREF="workers.html">SHWorkers</A> need to be
defined in and exported by an add-on or shared library.&nbsp; You may define
multiple <A HREF="workers.html">SHWorker</A> subclasses in the same add-on,
so for many programs, only one add-on file will be required.&nbsp; Just
set CodeWarrior to generate a "Shared Library", and put _EXPORT tags or
#pragma export ... #pragma reset around your <A HREF="workers.html">SHWorker</A>
subclass declarations, and you're ready to go!</LI>

<LI>
If you define the IsInterested() or GetName() methods for your <A HREF="workers.html">SHWorker</A>,
be aware that they may be called at any time, from another thread.&nbsp;
You may have to implement some kind of synchronization inside these methods
if the data they access ever changes.&nbsp; Also, you must call the SHWorker::Stop()
method as the first line in your subclass's destructor--otherwise, your
methods might get called after your destructor has freed the data they
access!&nbsp; This could cause a crash.</LI>

<LI>
When defining your implementations of the Archive() method and the constructor
that takes a (BMessage *), be sure to call the corresponding methods of
the parent class.&nbsp; If you don't, your <A HREF="workers.html">SHWorker</A>
objects won't get archived properly.&nbsp; The compiler doesn't give warning
messages about this, so be careful!</LI>
</UL>
<A NAME="sorters"></A>
<BR>&nbsp;

<P><B><U>Writing your own SHSorter subclasses</U></B>

<P>Writing an <A HREF="sorters.html">SHSorter</A> subclass is something
that most SockHop programs won't need to do--IMHO, the included <A HREF="wi1dpath.html">SHWi1dPathSorter</A>
class will be sufficient for 99% of the apps that might be written for
SockHop.&nbsp; However, custom message routing can be handy sometimes,
so SockHop lets you write your own BMessage routing algorithms by creating
<A HREF="sorters.html">SHSorter</A> subclasses and distributing your own
custom <A HREF="sorters.html">SHSorter</A> objects to the nodes in your
tree.&nbsp; To find out more about how to do this, read the <A HREF="sorters.html">SHSorter
class documentation</A>, and remember the following tips:
<UL>
<LI>
<A HREF="sorters.html">SHSorters</A> (unlike <A HREF="workers.html">SHWorkers</A>)
are "dead" objects that don't have their own thread;&nbsp; they run in
the node's message forwarding thread.&nbsp; So if your <A HREF="sorters.html">SHSorter</A>
is inefficient, it could slow down the entire node!</LI>

<LI>
It's possible when making a custom <A HREF="sorters.html">SHSorter</A>
to create routing algorithms that route BMessages in endless loops, or
even create "exponential BMessage explosions" that could eat all of your
systems' virtual memory very quickly!&nbsp; So be careful, and be especially
careful about under what circumstances you route BMessages back up the
tree...</LI>

<LI>
If you are going to use your custom <A HREF="sorters.html">SHSorter</A>
subclass objects for most or all of the routing, you can send out an <A HREF="sh_command_setparameters.html">SH_COMMAND_SETPARAMETERS</A>
BMessage to all the nodes in your tree that sets the default <A HREF="sorters.html">SHSorter</A>
to be your sorter.&nbsp; This will save you the trouble of having to explicitely
specify your <A HREF="sorters.html">SHSorter</A> by name in every BMessage
you send.</LI>
</UL>

</BODY>
</HTML>
