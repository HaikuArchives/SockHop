<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>SockHop Utility Functions</TITLE>
</HEAD>
<BODY>
<B>Global SockHop Functions</B>

<P>While most of the SockHop API is implemented through <A HREF="apis.html">C++
classes</A> and BMessage parsing, there are a few global, "C style" functions
exported by libsockhop.so.&nbsp; They are all defined in (sockhop/SockHopFunctions.h)
as follows:

<P>
<HR WIDTH="100%">
<BR><B>BLooper * SHCreateRootNode(const BMessenger &amp; repliesTo, <A HREF="accesspolicy.html">SHAccessPolicy</A>
* optPolicy = NULL)</B>

<P>This function is used by almost all SockHop programs.&nbsp; It returns
a BLooper object that you can send BMessages to to set up and control the
SockHop node tree.&nbsp; Whenever the SockHop tree has something to say
back to you, it will send a BMessage using a copy of the BMessenger you
specify in (repliesTo).

<P>Note that the returned BLooper acts just like a regular, freshly created
BLooper--you must call Run() on it before it will do anything on its own
(such as responding to BMessages you send it), and you should call Lock()
and Quit() on it when you are done with it.&nbsp; Note that calling Quit()
on this BLooper will cause the automatic destruction of any node tree you
created by sending BMessages to the BLooper.

<P>If (optPolicy) is specified, it should point to an <A HREF="accesspolicy.html">SHAccessPolicy</A>
object that has been allocated with SHCreateDistributableObject(), or with
the new operator.&nbsp; This <A HREF="accesspolicy.html">SHAccessPolicy</A>
object then becomes property of the root node--other code should not reference
it after this call returns.&nbsp; This policy object will be used to make
various access capability decisions during the lifetime of the root node.&nbsp;
If no <A HREF="accesspolicy.html">SHAccessPolicy</A> object is specified,
then an <A HREF="defaultaccesspolicy.html">SHDefaultAccessPolicy</A> object
is created internally and used.

<P>Note:&nbsp; This function may return NULL if an error occurs.

<P>
<HR WIDTH="100%">
<BR><B><A HREF="distributableobject.html">SHDistributableObject</A> * SHCreateDistributableObject(const
BMessage &amp; archive)</B>

<P>This method is a SockHop-friendly way of manually loading SockHop add-ons.&nbsp;
If your add-on derives from <A HREF="distributableobject.html">SHDistributableObject</A>
(as all SockHop add-ons should), you can load an instance of your class
into memory by calling this method.&nbsp; The object will be created based
on the BMessage you supply (which is passed to the Instantiate() method
of your <A HREF="distributableobject.html">SHDistributableObject</A> subclass).&nbsp;
Your BMessage may be one that was produced by an SHDistributableObject's
Archive() method, or you can fake it by hand-creating a BMessage with the
appropriate class name in the "class" field, and the appropriate SHFileSpec
flattened into the SH_NAME_ADDONSPEC field.&nbsp; Note that this function
does not attempt to <A HREF="sh_commands.html#addcomponents">download</A>
the necessary add-on file onto your machine--if the add-on isn't available
locally (in the file specified by the SH_NAME_ADDONSPEC field of (archive)),
this function will fail and return NULL.

<P>It's better to use this function than the bare load_add_on() and unload_add_on()
functions that Be provides, for two reasons:&nbsp; first, this function
is a little easier to use, but more importantly, because it is safer.&nbsp;
Here's why:&nbsp; if you ever run any SockHop nodes in your local process
space, they may be loading or unloading your add-on at various times.&nbsp;
Since add-on images are visible to the entire process, loading or unloading
an add-on will affect other threads if they are using that add-on.&nbsp;
That is, you might be executing code from the add-on when the SockHop node
thread decides to unload it!&nbsp; But if you use SHCreateDistributableObject()
and SHDeleteDistributableObject() to manage your SockHop add-ons, the add-on
images will be reference-counted correctly, and you won't crash and burn
mysteriously....

<P>
<HR WIDTH="100%">
<BR><B>void SHDeleteDistributableObject(<A HREF="distributableobject.html">SHDistributableObject</A>
* deleteMe)</B>

<P>This is the destructive counterpart to SHCreateDistributableObject().&nbsp;
Whenever you are done with an object you created using SHCreateDistributableObject(),
you should call this function to dispose of the object.&nbsp; DON'T just
delete the object with the delete operator--that will destroy the object, all right,
but the reference count won't be decremented, and you will end up wasting
memory on add-on images that could have been unloaded.

<P>Note that the opposite case is acceptable:&nbsp; if you have allocated
an <A HREF="distributableobject.html">SHDistributableObject</A> using the
new operator, it is legal to delete it with SHDeleteDistributableObject()
(which will just call the delete operator for you in this case).

<P>
<HR WIDTH="100%">
<BR><B>uint32 SHGetArchitectureBits()</B>

<P>Simply returns the SH_ARCH_* constant for the architecture that this
code is currently running on.
<BR>&nbsp;

<P><A HREF="index.html">Back to Top</A>
<BR>&nbsp;
</BODY>
</HTML>
