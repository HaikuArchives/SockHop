<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>SockHop SHWorker API</TITLE>
</HEAD>
<BODY>
<B><U>The SHWorker inheritance API</U></B> (derives
from <A HREF="component.html">SHComponent</A> -> <A HREF="distributableobject.html">SHDistributableObject</A>
-> BArchivable)

<P>If you want the nodes in your tree to do any useful work, you are going
to need to get your executable code out to them, and that means writing
an SHWorker subclass.&nbsp; SHWorkers aren't very complicated; they are
like BLoopers, but even easier to use!&nbsp; Note that SHWorkers inherit
from the <A HREF="component.html">SHComponent</A> class; this gives them
some handy methods they can call, as well as some pure virtual methods
that they must implement.

<P>SHWorkers, like BLoopers, have a MessageReceived() method that is called
whenever a BMessage arrives for them.&nbsp; Unlike BLoopers, however, SHWorkers
follow normal C++ object semantics--it is safe to put an SHWorker on the
stack if you want to, and you can delete an SHWorker using the delete operator
instead of calling Quit().&nbsp; Instead of a Run() method, SHWorkers have
Start() and Stop() methods.&nbsp; And you can't call PostMessage() on an
SHWorker to send it a BMessage--instead, you call GetMessenger() on it
to get a BMessenger that targets the SHWorker, and then call SendMessage()
on the BMessenger.

<P>The methods you are required to implement in your SHWorker subclass
are few.&nbsp; They are:

<P>
<HR WIDTH="100%">
<BR><B>SHWorker(BMessage * archive)</B>

<P>You must create a constructor for your class that can create an object
from the data contained in the passed-in BMessage.&nbsp; This constructor
essentially does the opposite of your Archive() method;&nbsp; instead of
converting an object to a BMessage, it converts a BMessage back to an object.&nbsp;
Be sure to call SHWorker(archive) in the initialization list!

<P>
<HR WIDTH="100%">
<BR><B>static BArchivable * Instantiate(BMessage * archive)</B>

<P>This static method (part of the BArchivable API) is also used to turn
BMessages back into real objects, and should be implemented like this:

<P><TT><NOBR>BArchivable *</NOBR></TT>
<BR><TT><NOBR>MySHWorkerSubclass::</NOBR></TT>
<BR><TT><NOBR>Instantiate(BMessage * archive)</NOBR></TT>
<BR><TT><NOBR>{</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // replace the second argument to validate_instantiation
with your class's name!</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; if (!validate_instantiation(archive, "MySHWorkerSubclass"))
return NULL;</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; return new MySHWorkerSubclass(archive);</NOBR></TT>
<BR><TT><NOBR>}</NOBR></TT>

<P>
<HR WIDTH="100%">
<BR><B>virtual status_t GetAddOnSpec(SHFileSpec &amp; addTo) const</B>

<P>This method (part of the <A HREF="distributableobject.html">SHDistributableObject</A>
API) should be overridden to return an <A HREF="shfilespecs.html">SHFileSpec</A>
that indicates where the add-on executable file(s) for this class can be
found.&nbsp; Like BArchivable::Archive(), each subclass should call the
GetAddOnSpec() method of its parent class;&nbsp; in this way the <A HREF="shfilespecs.html">SHFileSpec</A>
gets built up into a list of all the files needed to instantiate the object.

<P><NOBR><TT>status_t</TT></NOBR>
<BR><TT><NOBR>MySHWorkerSubclass::GetAddOnSpec(<A HREF="shfilespecs.html">SHFileSpec</A>
&amp; spec) const</NOBR></TT><NOBR></NOBR>
<BR><NOBR><TT>{</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp; status_t ret;</TT></NOBR><NOBR></NOBR>

<P><TT><NOBR>&nbsp;&nbsp; // Allow our parent class to say what files he
needs</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; ret = SHWorker::GetAddOnSpec(spec);</NOBR></TT>
<BR><NOBR><TT>&nbsp;&nbsp; if (ret != B_NO_ERROR) return ret;</TT></NOBR><NOBR></NOBR>

<P><TT><NOBR>&nbsp;&nbsp; // Specify location of Intel version of the add-on
file</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; <A HREF="shflavors.html">SHFlavor</A> x86("add-ons/x86/SHMyWorkerSubclassAddOn",
SH_ARCH_BEOS_X86);</NOBR></TT><NOBR></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp; ret = spec.AddFlavor(x86);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp; if (ret != B_NO_ERROR) return ret;</TT></NOBR><NOBR></NOBR>

<P><TT><NOBR>&nbsp;&nbsp; // Specify location of the PowerPC version of
the add-on file</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; <A HREF="shflavors.html">SHFlavor</A> ppc("add-ons/ppc/SHMyWorkerSubclassAddOn",
SH_ARCH_BEOS_PPC);</NOBR></TT><NOBR></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp; ret = spec.AddFlavor(ppc);</TT></NOBR>
<BR><NOBR><TT>&nbsp;&nbsp; if (ret != B_NO_ERROR) return ret;</TT></NOBR><NOBR></NOBR>

<P><NOBR><TT>&nbsp;&nbsp; return B_NO_ERROR;</TT></NOBR>
<BR><NOBR><TT>}</TT></NOBR>

<P>
<HR WIDTH="100%">
<BR><A NAME="GetName"></A><B>virtual const char * GetName()</B>

<P>This method (part of the SHComponent API) should be overridden to supply
an identifying text string for your SHWorker object.&nbsp; There are no
conditions imposed on what this name is, in particular it is not required
(by SockHop) to be unique in any way.&nbsp; This name can be used to identify
the SHWorker in <A HREF="wi1dpath.html#ToWorkers">certain situations</A>,
however, so it's not a bad idea to make each SHWorker's name unique.

<P>
<HR WIDTH="100%">
<BR><B>virtual status_t Archive(BMessage * archive, bool deep=true) const</B>

<P>This method must be overridden to store all relevant state for your
SHWorker into (archive).&nbsp; This method helps fulfill the SHWorker's
BArchivable interface, and is how your SHWorker object gets transported
over the TCP streams.&nbsp; At a bare minimum, your Archive() method should
look like this:

<P><TT><NOBR>status_t</NOBR></TT>
<BR><TT><NOBR>SHTestWorker::</NOBR></TT>
<BR><TT><NOBR>Archive(BMessage * archive, bool deep) const</NOBR></TT>
<BR><TT><NOBR>{</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // Let our base class do its archiving first</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; status_t ret = SHWorker::Archive(archive, deep);</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; if (ret != B_NO_ERROR) return ret;</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; // store any additional data describing the current
state</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // of this SHTestWorker object into the BMessage
here</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; // ...</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; return B_NO_ERROR;</NOBR></TT>
<BR><TT><NOBR>}</NOBR></TT>

<P>
<HR WIDTH="100%">
<BR><B><U>Class Destructor</U></B>

<P>One more requirement is placed on SHWorkers--they must call the Stop()
method at the beginning of their destructor method.&nbsp; This is necessary
to avoid race conditions during the destruction of the SHWorker object.&nbsp;
If you forget the Stop() call, you will get warning messages printed to
stdout, and the SockHop node may crash.

<P>
<HR WIDTH="100%">
<BR>And there are some methods which you may override if you wish, but
don't have to:

<P>
<HR WIDTH="100%">
<BR><B>virtual void MessageReceived(BMessage * msg)</B>

<P>This, of course, is equivalent to the standard BLooper method to handle
incoming BMessages.&nbsp; You don't have to implement it, but if you don't
your SHWorker won't do very much that is interesting!

<P>
<HR WIDTH="100%">
<BR><A NAME="IsInterestedIn"></A><B>virtual bool IsInterestedIn(BMessage
* msg)</B>

<P>This method can be used as an optimization, to cut down on the number
of BMessages sent to your SHWorker.&nbsp; Before sending any BMessage to
your SHWorker, the SockHop node thread calls this method to see if your
SHWorker wants it.&nbsp; The default implementation of this method just
returns true; which is to say, by default an SHWorker is "interested in"
every kind of BMessage.&nbsp; If you wish, you can override this method
to return false for BMessages that your SHWorker can't use.&nbsp; That
will save the overhead of sending a BMessage that will be ignored anyway.&nbsp;
It is important to remember, however, that IsInterestedIn() will be called
from a thread other than the SHWorker's thread, and that by default no
locking occurs to synchronize access to the data in your SHWorker object.&nbsp;
Thus, you may need to serialize access yourself (by calling Lock() and
Unlock()) in this method.
<BR>&nbsp;
<BR>&nbsp;
</BODY>
</HTML>
