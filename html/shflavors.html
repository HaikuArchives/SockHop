<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>SHFlavor API</TITLE>
</HEAD>
<BODY>
&nbsp;<B><U>The SHFlavor class</U></B>
<BR>&nbsp;

<P>The SHFlavor class is used by SockHop to specify a single file on disk
for purposes of downloading and caching.&nbsp; The common usage of SHFlavors
is to add them to an <A HREF="shfilespecs.html">SHFileSpec</A> object that
specifies what files must be available on the local disk in order for an
add-on to be instantiated.&nbsp; Each SHFlavor is a simple data container,
storing the following information:
<UL>
<LI>
A file path that specifies where the file can be found and where it will
be cached.</LI>

<LI>
An optional, second file path that specifies where the file (can be found/should
be placed) on its "native" hardware platform</LI>

<LI>
The hardware architecture (or architectures) that the file is usable on.</LI>

<LI>
The size of the file, in bytes</LI>

<LI>
The modification time of the file</LI>

<LI>
Whether or not the file is an add-on file</LI>
</UL>
This information is used by the caching system to determine when files
need to be downloaded from parent to child nodes, and where to place the
cached files it downloads.
<BR>&nbsp;
<BR>
<HR WIDTH="100%">
<BR><B>SHFlavor()</B>

<P>Default constructor, creates an invalid SHFlavor object.&nbsp; The only
use for the created object is to copy another SHFlavor into it (using the
'=' operator or one of the methods in <A HREF="shfilespecs.html">SHFileSpec</A>).

<P>
<HR WIDTH="100%">
<BR><B>SHFlavor(const SHFlavor &amp; copyMe)</B>

<P>Copy constructor.

<P>
<HR WIDTH="100%"><B>SHFlavor(const char * fileName, bool isAddOn)</B>

<P>Creates an SHFlavor by reading the appropriate information out of the
file specified by (fileName).&nbsp; (fileName) may include a relative or
absolute file path.&nbsp; The file's architecture bits will be set to SH_ARCH_ANY,
meaning the the file is appropriate for all hardware platforms BeOS runs
on.

<P>The other argument, isAddOn, must be specified manually.&nbsp; This
flag determines whether or not the object instantiation system will attempt
to call load_add_on() on this file before instantiating an <A HREF="distributableobject.html">SHDistributableObject</A>
that includes this SHFlavor.&nbsp; You should only set (isAddOn) to be
true if this file is an add-on which contains some or all of the code for
your <A HREF="distributableobject.html">SHDistributableObject</A> subclass.&nbsp;
Set (isAddOn) to false for other executables, shared libraries, data files,
etc.

<P>Note that errors can occur in this constructor, so the resulting object
may not always be valid.&nbsp; To make sure everything went okay, call
InitCheck() on this object, or check the result of AddFlavor() when you
go to add this SHFlavor to its <A HREF="shfilespecs.html">SHFileSpec</A>().&nbsp;
(AddFlavor() will not accept invalid SHFlavors).

<P>
<HR WIDTH="100%">
<BR><B>SHFlavor(const char * fileName, uint32 architectureBits, bool isAddOn)</B>

<P>This constructor is the same as the previous one, with the addition
of the (architectureBits) argument that lets you specify that this SHFlavor
is apropos only to certain types of hardware.&nbsp; For example, if (fileName)
specifies a PowerPC executable, you would want to set (architectureBits)
to SH_ARCH_BEOS_PPC.&nbsp; If the file is usable by more than one hardware
architecture, you may use the bit-wise OR operator ('|') to combine constants--i.e.
a file usable on both PowerPC and Intel hardware would be signified by
(SH_ARCH_BEOS_PPC | SH_ARCH_BEOS_X86).

<P>
<HR WIDTH="100%">
<BR><B>SHFlavor(const char * cacheName, const char * nativeName, uint32
architectureBits, bool isAddOn)</B>

<P>This constructor is the same as the previous one, except that this one
allows you to specify <I>two</I> locations for your file.&nbsp; The first
location, specified by (cacheName), will be used by all SockHop nodes running
on computers whose hardware architectures are <I>not</I> specified by (architectureBits).&nbsp;
The second location, (nativeName) will be used by SockHop nodes whose hardware
(architectureBits) <I>does</I> specify.

<P>Why is this useful?&nbsp; Because in certain situations, it's necessary
to keep the native flavor of a file in a well-know location.&nbsp; Take
a shared library, for example.&nbsp; It is expected to be in a known spot
("/boot/home/config/lib/libfoo.so") on the hard drive, regardless of whether
the system is PowerPC or Intel based.&nbsp; This could cause a problem,
since even though an Intel system would never need to use a PowerPC library
itself, it still may need to cache the PowerPC library on its local disk
somewhere, so that its children can get the library quickly.&nbsp; For
this and similar situations, you could use SHFlavors like this:

<P><TT><NOBR>status_t</NOBR></TT>
<BR><TT><NOBR>FooObject ::</NOBR></TT>
<BR><TT><NOBR>GetAddOnSpec(<A HREF="shfilespecs.html">SHFileSpec</A> &amp;
writeTo) const</NOBR></TT>
<BR><TT><NOBR>{</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; SHFlavor x86("/boot/home/config/lib/libfoo.so.x86",
"/boot/home/config/lib/libfoo.so", SH_ARCH_BEOS_X86, false);</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; SHFlavor ppc("/boot/home/config/lib/libfoo.so.ppc",
"/boot/home/config/lib/libfoo.so", SH_ARCH_BEOS_PPC, false);</NOBR></TT>

<P><TT><NOBR>&nbsp;&nbsp; (void) writeTo.AddFlavor(x86);&nbsp;&nbsp; //
Note:&nbsp; no error checking in this example... in general</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; (void) writeTo.AddFlavor(ppc);&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
though it's a good idea to check results here in case the</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected files are missing</NOBR></TT>
<BR><TT><NOBR>&nbsp;&nbsp; return B_NO_ERROR;</NOBR></TT>
<BR><TT><NOBR>}</NOBR></TT>

<P>This way, your cached non-native files won't collide with your in-use,
native files.
<BR>&nbsp;

<P>
<HR WIDTH="100%">
<BR><B>SHFlavor(const char * cacheName, uint32 archs, uint64 fileSize,
uint32 creationTime, bool isAddOn)</B>
<BR><B>SHFlavor(const char * cacheName, const char * nativeName, uint32
archs, uint64 fileSize, uint32 creationTime, bool isAddOn)</B>

<P>These two constructors allow you to specify all data fields of the SHFlavor
explicitely.&nbsp; Since these constructors (unlike all the others) do
not actually look at any files on your hard disk, they are guaranteed always
to produce "valid" SHFlavor objects (that is, InitCheck() will return B_NO_ERROR
for them).&nbsp; However, if the information you give is not correct, then
SockHop's caching mechanisms may not function correctly.&nbsp; (The most
likely malfunction is that SockHop will re-download cached files unecessarily)&nbsp;
Because of this, use of these constructors is discouraged unless absolutely
necessary.

<P>
<HR WIDTH="100%"><B>SHFlavor &amp; operator =(const SHFlavor &amp; copyMe)</B>

<P>Assignment operator.&nbsp;&nbsp; All fields are copied verbatim.

<P>
<HR WIDTH="100%">
<BR><B>bool operator ==(const SHFlavor &amp; compareMe) const</B>

<P>Comparison operator.&nbsp; Two SHFlavors are considered equal if all
of their fields are equal.&nbsp; The exception is the "isAddOn" property,
which is ignored for this comparison.

<P>
<HR WIDTH="100%">
<BR><B>bool operator !=(const SHFileSpec &amp; compareMe) const</B>

<P>Comparison operator.&nbsp; Returns the opposite of what '==' would return.
<BR>&nbsp;
<BR>
<HR WIDTH="100%"><B>virtual status_t Flatten(void * buf, ssize_t numBytes)
const</B>
<BR><B>virtual status_t Unflatten(type_code code, const void * buf, ssize_t
numBytes)</B>
<BR><B>virtual ssize_t FlattenedSize() const</B>
<BR><B>virtual type_code TypeCode() const</B>
<BR><B>virtual bool IsFixedSize() const</B>

<P>These methods implement the BFlattenable interface for SHFlavor.&nbsp;
They work pretty much the way you would expect.&nbsp; Note that these methods
will not work on an invalid SHFlavor object (they will return B_ERROR,
etc).

<P>
<HR WIDTH="100%">
<BR><B>const char * GetCacheName() const</B>

<P>Returns the filepath indicating the location where the file will be
cached, as was specified in the constructor.&nbsp; Returns NULL if the
SHFlavor object is invalid.
<BR>&nbsp;
<HR WIDTH="100%">
<BR><B>const char * GetNativeName() const</B>

<P>Returns a filepath indicating where the file will be cached on "native"
platforms, as was indicated in the constructor.&nbsp; If (nativeName) was
not specified in the constructor, then this method will return the same
value as GetCacheName().&nbsp; See the constructor documentation above
for info on cached versus native locations.&nbsp; Returns NULL if the SHFlavor
object is invalid.

<P>
<HR WIDTH="100%">
<BR><B>const char * GetSuggestedName() const</B>

<P>A simple convenience function that returns the native name if the local
hardware is "native", otherwise the cached name.&nbsp; Implemented with
logic equivalent to "if (SupportsArchitecture(<A HREF="functions.html">SHGetArchitectureBits</A>())
then return GetNativeName() else return GetCacheName()".

<P>
<HR WIDTH="100%">
<BR><B>uint32 SHGetArchitectureBits() const</B>

<P>Returns a bit-chord indicating which hardware architecture or architectures
may make use of this SHFlavor's file (as was specified in the constructor).&nbsp;
For example, an SHFlavor representing an Intel executable file might return
SH_ARCH_BEOS_X86 from this method, whereas an SHFlavor representing a .JPEG
file might return SH_ARCH_ANY.

<P>
<HR WIDTH="100%">
<BR><B>uint64 GetSize() const</B>

<P>Returns the size of the specified file, in bytes.&nbsp; Result undefined
if the SHFlavor is invalid.
<BR>&nbsp;
<HR WIDTH="100%">
<BR><B>time_t GetModificationTime() const</B>

<P>Returns the modification timestamp of the file as was determined in
the constructor.&nbsp; Result undefined if the SHFlavor is invalid.

<P>
<HR WIDTH="100%">
<BR><B>bool IsAddOn() const</B>

<P>Returns a boolean indicating whether or not the file is to be treated
as an add-on file (as was specified in the constructor).

<P>
<HR WIDTH="100%">
<BR><B>void PrintToStream() const</B>

<P>Dumps the state of the SHFlavor to stdout.
<BR>&nbsp;
<HR WIDTH="100%">
<BR><B>bool SupportsArchitecture(uint32 bits) const</B>

<P>Returns true iff all the bits found in the bitchord returned by SHGetArchitectureBits()
are also found in (bits)--that is, iff (bits) is a superset of SHGetArchitectureBits().&nbsp;
Calling this method with the current architecture's bits (as returned by
<A HREF="functions.html">SHGetArchitectureBits</A>()) as an argument is
how SockHop determines whether an SHFlavor is "native" (i.e. usable by
the hardware of the local machine) or not.

<P>
<HR WIDTH="100%">
<BR><B>status_t InitCheck() const</B>

<P>Returns B_NO_ERROR if this SHFlavor object is valid, some other value
if it's not.&nbsp; If an SHFlavor is invalid, it's usually because its
constructor specified a file that did not exist on the local disk, or was
not readable.&nbsp; Invalid SHFlavors are pretty useless, as SHFileSpecs
will not accept them.
</BODY>
</HTML>
