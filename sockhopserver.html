<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeremy Friesner">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (WinNT; I) [Netscape]">
   <TITLE>Using the SockHopServer program</TITLE>
</HEAD>
<BODY>
<B><U>The SockHop server</U></B>

<P>When a SockHop program runs, it needs to create processes on (potentially)
many different computers.&nbsp; However, before it can do this, there has
to be some software already running on each computer, that knows how to
accept a SockHop connection and create SockHop nodes.&nbsp; The program
that does this is called the SockHop server.

<P>Before you can use a computer as a "slave" SockHop host, you need to
(manually) launch the server executable on it.&nbsp; The SockHop server
executable is, in fact, the libsockhop.so library file!&nbsp; The BeOS
object model allows this one file to do double duty as both shared library
and server executable.&nbsp; Once the SockHop server is running on all
your computers, SockHop can take care of everything else by itself, and
you need not do anything with any of the slave computers after that.&nbsp;
Even if the node processes that your program launches on the slave computer
crash (which does happen when you are developing new software!), the SockHop
server will keep on working.&nbsp; This is because each incoming connection
is placed into its own address space, so that a buggy node cannot corrupt
the main launcher process.

<P><B><U>SockHop server usage format</U></B>

<P>Currently, the SockHop server must be run from a shell.&nbsp; It takes
zero or more arguments to modify its behavior.&nbsp; An example invocation
of the server might be:

<P>~/config/lib/libsockhop.so port=5555 password=topsecret debug=1 priority=7
encoding=zlibmedium

<P>The above invocation exercises all the options of the <A HREF="defaultaccesspolicy.html">SHDefaultAccessPolicy</A>
that is used by default--it runs a server with debug printing on, listening
on port 5555, which requires the password "topsecret" from all connecting
clients.&nbsp; It spawns threads at priority 7, and encodes outgoing BMessages
with "medium" zlib compression.&nbsp; All arguments are optional, so you
could also just run the server like this:

<P>~/config/lib/libsockhop.so

<P>This would run the server on the default port (2958), with debug printing
off, no password required, threads at priority 10, no BMessage compression.&nbsp;
Note that this is a security hole roughly equivalent to allowing password-less
telnet and ftp access to your computer, so unless you are on an isolated
network, I highly recommend you specify a password!
<BR>&nbsp;

<P><B><U>Choose where SockHopServer should put its cached files</U></B>

<P>Generally, nodes that the SockHop server launches will cache their files
in the SockHop server's current directory.&nbsp; So it is a good idea to
launch the SockHop server from a directory that you have made especially
for it, e.g.

<P><TT>mkdir ~/SockHopData</TT>
<BR><TT>cd ~/SockHopData</TT>
<BR><TT>~/config/libsockhop.so password=topsecret</TT>

<P>The SockHopServer's current directory should be readable and writable,
and have enough free space for the files that you will be caching in it.&nbsp;
SockHop doesn't provide a mechanism for removing files once they have been
cached, so you may want to periodically go through and delete any contents
of this directory that you are no longer using.&nbsp; (Note that you only
need to do this to recover disk space; a properly written SockHop program
will never use out-of-date versions of any cached file, but rather will
automatically overwrite them with the current version on each node that
uses the file)

<P>You can run multiple SockHop servers at once on a single computer, if
you like, as long as you have each one listen on a different port number.&nbsp;
This can be helpful if you want to separate your debug output into multiple
windows, or if you want to maintain separate cached-file archives, each
in its own directory.&nbsp; But since each SockHop server can accept any
number of simultaneous connections, this isn't ever really necessary.
<BR>&nbsp;
<BR><B><U>Using your own custom <A HREF="accesspolicy.html">SHAccessPolicy</A>
object</U></B>

<P>If the <A HREF="defaultaccesspolicy.html">SHDefaultAccessPolicy</A>
that the SockHop server isn't sophisticated enough for you, you can write
your own access policy as an add-on.&nbsp; Simply subclass the <A HREF="accesspolicy.html">SHAccessPolicy</A>
class in your add-on, and then specify your add-on file when you run the
SockHop server, as shown below:

<P>~/config/lib/libsockhop.so policy=add-ons/MyPolicyAddOn

<P>If your <A HREF="accesspolicy.html">SHAccessPolicy</A> subclass's name
is the same as the add-on's filename, this will be enough to get your add-on
policy to be used.&nbsp; If it differs, however, you need to specify the
class name as well:

<P>~/config/lib/libsockhop.so policy=add-ons/MyPolicyAddOn class=MyPolicyClass

<P>Any other parameters you put on the command line will be added as string
fields to the BMessage which is passed to your class's Instantiate() method.&nbsp;
(Indeed, this is how the <A HREF="defaultaccesspolicy.html">SHDefaultAccessPolicy</A>
gets its parameters from the command line!).&nbsp; So, a command line like
this:

<P>~/config/lib/libsockhop.so policy=add-ons/MyPolicyAddOn class=MyPolicyClass
color=purple number=42 sad=true

<P>Would instantiate a MyPolicyClass object via it's (BMessage *) constructor,
using this BMessage:

<P>what = &lt;unset>
<BR>String field "color" = "purple"
<BR>String field "number" = "42"
<BR>String field "sad" = "true"
<BR>String field "class" = "MyPolicyClass"
<BR>Flattened field SH_NAME_ADDONSPEC = (flattened <A HREF="shfilespecs.html">SHFileSpec</A>
containing the path "add-ons/MyPolicyAddOn" for the current architecture)

<P>Again, note that all parameters (except the "policy" parameter, which
is a special case) are added as Strings only!

<P><A HREF="index.html">Back to top</A>
</BODY>
</HTML>
